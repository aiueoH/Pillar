package com.pillar;

import java.util.ArrayList;

import org.andengine.engine.camera.SmoothCamera;
import org.andengine.engine.camera.hud.HUD;
import org.andengine.engine.handler.timer.ITimerCallback;
import org.andengine.engine.handler.timer.TimerHandler;
import org.andengine.entity.primitive.Line;
import org.andengine.entity.primitive.Rectangle;
import org.andengine.entity.scene.Scene;
import org.andengine.entity.scene.background.Background;
import org.andengine.entity.text.Text;
import org.andengine.opengl.font.Font;
import org.andengine.opengl.font.FontFactory;
import org.andengine.opengl.font.FontManager;
import org.andengine.opengl.texture.TextureManager;
import org.andengine.opengl.vbo.VertexBufferObjectManager;
import org.andengine.util.math.MathUtils;

import android.R.integer;
import android.graphics.Typeface;
import android.util.Log;

public class GameController implements IBrickOwner {

	public static final float CAMERA_WIDTH = 480, CAMERA_HEIGHT = 800;
	public static final float SCENE_WIDTH = 480, SCENE_HEIGHT = 3000;
	public static final float DEFAULT_CAM_VEL_X = 1f, DEFAULT_CAM_VEL_Y = 3000f, DEFAULT_CAM_VEL_Z = 1f;
	public static final int PILLARBRICK_LINKED_THRESHOLD = 5;
	
	private VertexBufferObjectManager vertexBufferObjectManager;
	private FontManager fontManager;
	private TextureManager textureManager;
	private Scene scene;
	private SmoothCamera camera;
	private HUD hud;
	
	private ArrayList<Brick> bricks;
	private int bottomBrickIndex;
	// HUD
	private Text completeText;
	private Line[] progressBarLine = new Line[4];
	private Rectangle progressBarRect;
	private final float PROGRESSBAR_HEIGHT = 600f;
	private final float PROGRESSBAR_X = 20f;
	private final float PROGRESSBAR_Y = 50f;
	private TimerHandler timerHandler;
	private final float TIME_MAX = 60f;
	private final float TIMER_SECOND = 0.1f;
	private float time = 60f;
	
	private BarTimer barTimer;
	
	public GameController() {
		this.bricks = new ArrayList<Brick>();
		this.camera = new SmoothCamera(0, 0, GameController.CAMERA_WIDTH, GameController.CAMERA_HEIGHT, GameController.DEFAULT_CAM_VEL_X, GameController.DEFAULT_CAM_VEL_Y, GameController.DEFAULT_CAM_VEL_Z);
	}
	
	public void initScene() {
		this.scene = new Scene();
		this.scene.setBackground(new Background(0.5f, 0.3f, 0.8f));
		initBrick();
		float pCenterX = SCENE_WIDTH - CAMERA_WIDTH / 2;
		float pCenterY = SCENE_HEIGHT - CAMERA_HEIGHT / 2;
		this.camera.setCenterDirect(pCenterX, pCenterY);
		tryChaseBrickAtBottom();

		this.hud = new HUD();
		// text
		Font font = FontFactory.create(this.fontManager, this.textureManager, 256, 256, Typeface.create(Typeface.DEFAULT, Typeface.BOLD), 32);
		font.load();
		completeText = new Text(0, 0, font, "01234567890123456789", this.vertexBufferObjectManager);
		int rate = (int)((float)countLinkedBrick() / 100f * 100f);
		this.completeText.setText("Complete " + rate + "%");
		hud.attachChild(completeText);
		// progress bar
		{
//			float w = 20, h = this.PROGRESSBAR_HEIGHT;
//			float x = this.PROGRESSBAR_X, y = this.PROGRESSBAR_Y;
//			float strokeW = 3f;
//			this.progressBarRect = new Rectangle(x, y, w, h, this.vertexBufferObjectManager);
//			this.progressBarRect.setColor(0f, 1f, 0f);
//			this.hud.attachChild(this.progressBarRect);
//			this.progressBarLine[0] = new Line(x, y, x + w, y, strokeW, this.vertexBufferObjectManager);
//			this.progressBarLine[1] = new Line(x + w, y, x + w, y + h, strokeW, this.vertexBufferObjectManager);
//			this.progressBarLine[2] = new Line(x + w, y + h, x, y + h, strokeW, this.vertexBufferObjectManager);
//			this.progressBarLine[3] = new Line(x, y + h, x, y, strokeW, this.vertexBufferObjectManager);
//			for (int i = 0; i < this.progressBarLine.length; i++) {
//				this.hud.attachChild(this.progressBarLine[i]);
//			}
		}
		this.camera.setHUD(hud);
		
		timerHandler = new TimerHandler(TIMER_SECOND, true, new ITimerCallback() {
			@Override
			public void onTimePassed(TimerHandler pTimerHandler) {
				Log.v("Wei", "time " + time);
				if (time > 0) {
					time -= TIMER_SECOND;
					float percent = time / TIME_MAX;
					progressBarRect.setHeight(PROGRESSBAR_HEIGHT * percent);
					progressBarRect.setY(PROGRESSBAR_Y + PROGRESSBAR_HEIGHT * (1f - percent));
				} else 
					stopTimer();
			}
		});
		
		
		
		this.scene.registerUpdateHandler(timerHandler);
	}
	
	private void stopTimer() {
		this.timerHandler.setAutoReset(false);
		this.scene.unregisterUpdateHandler(timerHandler);
	}
	
	public void initBrick() {
		for (int i = 0, pCount = 0; pCount < 100; i++) {
			float pX = CAMERA_WIDTH / 2 - Brick.DEFAULT_WIDTH / 2;
			float pY = SCENE_HEIGHT - (i + 1) * Brick.DEFAULT_HEIGHT;
			Brick brick;
			if (MathUtils.random(0, 5) != 0) {
				brick = new PillarBrick(pX, pY, this.vertexBufferObjectManager, this);
				pCount++;
			} else
				brick = new NoiseBrick(pX, pY, this.vertexBufferObjectManager, this);
			addBrick(brick);
		}
		this.bottomBrickIndex = 0;
	}
	
	private void addBrick(Brick brick) {
		this.scene.attachChild(brick);
		this.scene.registerTouchArea(brick);
		this.bricks.add(brick);
	}
	
	public SmoothCamera getSmoothCamera() {
		return this.camera;
	}
	
	public Scene getScene() {
		return this.scene;
	}
	
	public void setVertexBufferObjectManager(VertexBufferObjectManager vertexBufferObjectManager) {
		this.vertexBufferObjectManager = vertexBufferObjectManager;
	}
	
	public void setTextureManager(TextureManager textureManager) {
		this.textureManager = textureManager;
	}
	
	public void setFontManager(FontManager fontManager) {
		this.fontManager = fontManager;
	}
	
	@Override
	public void onBrickBreaking(Brick brick) {
		int index = this.bricks.indexOf(brick);
		deleteBrick(brick);
		for (int i = index; i < this.bricks.size(); i++)
			this.bricks.get(i).moveDown();
		
		int rate = (int)((float)countLinkedBrick() / 100f * 100f);
		this.completeText.setText("Complete " + rate + "%");
	}
	
	@Override
	public void onBrickMoveDownFinished(Brick brick) {
		tryChaseBrickAtBottom();
	}
	
	private boolean isPillarBrickLinked(int n) {
		for (int i = 0; i < n; i++) {
			int index = this.bottomBrickIndex + i;
			if (index >= this.bricks.size() || !(this.bricks.get(index) instanceof PillarBrick))
				return false;
		}
		Log.v("Wei", "isPillarBrickLinked true");
		return true;
	}
	
	private void tryChaseBrickAtBottom() {
		while (isPillarBrickLinked(GameController.PILLARBRICK_LINKED_THRESHOLD)) {
			final int targetIndex = this.bottomBrickIndex + GameController.PILLARBRICK_LINKED_THRESHOLD;
			if (targetIndex < this.bricks.size()) {
				Brick targetBrick = this.bricks.get(targetIndex);
				chaseBrickAtBottom(targetBrick);
			} else 
				break;
		}
	}
	
	private void chaseBrickAtBottom(Brick brick) {
		float cY = brick.getY() + brick.getHeight() * 2 - this.camera.getHeight() / 2;
		this.camera.setCenter(this.camera.getCenterX(), cY);
		this.bottomBrickIndex = this.bricks.indexOf(brick);
	}

	
	private boolean hasNoiseBrick() {
		for (Brick b : this.bricks)
			if (b instanceof NoiseBrick)
				return true;
		return false;
	}
	
	private int countLinkedBrick() {
		int c = 0;
		for (Brick b : this.bricks)
			if (b instanceof PillarBrick)
				c++;
			else
				break;
		return c;
	}
	
	private void deleteBrick(Brick brick) {
		this.scene.unregisterTouchArea(brick);
		this.scene.detachChild(brick);
		brick.detachSelf();
		brick.dispose();
		this.bricks.remove(brick);
	}

}
